<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Town Hub</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <div id="game-container">
    <canvas id="town"></canvas>
    <div id="chat-overlay" class="hidden">
      <div id="messages"></div>
      <form id="chat-form">
        <input id="chat-input" placeholder="Say something..." autocomplete="off"/>
      </form>
    </div>
    <div id="game-prompt" class="hidden">Press SPACE to start game</div>
    <div id="arcade-menu" class="hidden" style="position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(11,18,32,0.95);padding:18px;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.6);z-index:999">
      <h3 style="color:#e6eef8;margin:0 0 8px 0">Choose Arcade Game</h3>
      <div style="display:flex;gap:8px">
        <button id="arcade-pong">Pong</button>
        <button id="arcade-breakout" class="secondary">Breakout</button>
        <button id="arcade-cancel" class="secondary">Cancel</button>
      </div>
    </div>
    <button id="change-name" class="overlay-button">Name</button>
  </div>

<script>
(() => {
  const canvas = document.getElementById('town');
  const ctx = canvas.getContext('2d');

  // Set canvas size to window size and maintain game scale
  let canvasScale = 1;
  // Increase the logical map size to 2000x2000
  const GAME_WIDTH = 2000;
  const GAME_HEIGHT = 2000;
  
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    canvasScale = Math.min(canvas.width / GAME_WIDTH, canvas.height / GAME_HEIGHT);
    ctx.setTransform(canvasScale, 0, 0, canvasScale, 0, 0);
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // UI elements
  const chatOverlay = document.getElementById('chat-overlay');
  const gamePrompt = document.getElementById('game-prompt');
  function getCanvasCoordsFromTouch(touch) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return { x: (touch.clientX - rect.left) * scaleX, y: (touch.clientY - rect.top) * scaleY };
  }

  // Touch drag to move player (mobile): update position and send move immediately
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (!you) return;
    const t = e.touches[0];
    const pos = getCanvasCoordsFromTouch(t);
    you.x = Math.max(10, Math.min(canvas.width - 10, pos.x));
    you.y = Math.max(10, Math.min(canvas.height - 10, pos.y));
    players[you.id] = you;
    ws.send(JSON.stringify({type: 'move', x: you.x, y: you.y}));
  }, {passive:false});

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (!you) return;
    const t = e.touches[0];
    const pos = getCanvasCoordsFromTouch(t);
    you.x = Math.max(10, Math.min(canvas.width - 10, pos.x));
    you.y = Math.max(10, Math.min(canvas.height - 10, pos.y));
    players[you.id] = you;
    ws.send(JSON.stringify({type: 'move', x: you.x, y: you.y}));
  }, {passive:false});

  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    // no-op for now
  }, {passive:false});

  // Mobile screen handling
  function updateMobileLayout(){
    if(window.innerWidth <= 800){
      document.body.classList.add('mobile');
    } else {
      document.body.classList.remove('mobile');
    }
  }
  window.addEventListener('resize', updateMobileLayout);
  updateMobileLayout();

  // Map areas
  // Two separate buildings: Pong and Breakout
  const areas = [
    {name: 'pong', x: 600, y: 200, w: 180, h: 160, color: '#e0e7ff', label: 'PONG', borderColor: '#4f46e5', icon: '/static/pong.svg'},
    {name: 'breakout', x: 900, y: 200, w: 180, h: 160, color: '#fef3c7', label: 'BREAKOUT', borderColor: '#f59e0b', icon: '/static/breakout.svg'}
  ];

  // Preload area icons
  const areaIcons = {};
  areas.forEach(a => {
    if (a.icon) {
      const img = new Image();
      img.onload = () => { a.iconLoaded = true; };
      img.onerror = () => { a.iconLoaded = false; };
      img.src = a.icon;
      areaIcons[a.name] = img;
    }
  });

  // player state
  let you = null;
  const players = {}; // id -> player

  // WebSocket
  const loc = window.location;
  const wsProtocol = (loc.protocol === 'https:') ? 'wss' : 'ws';
  const ws = new WebSocket(wsProtocol + '://' + loc.host + '/ws');
  let needToJoin = false;
  let hasJoined = false;

  // UI hooks
  const messages = document.getElementById('messages');
  const playersList = document.getElementById('players');
  const chatForm = document.getElementById('chat-form');
  const chatInput = document.getElementById('chat-input');
  const enterArcade = document.getElementById('enter-arcade');
  let minigameWin = null;

  function addMessage(text) {
    const d = document.createElement('div'); d.className = 'msg'; d.textContent = text;
    messages.appendChild(d); messages.scrollTop = messages.scrollHeight;
  }

  function render() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // background
    ctx.fillStyle = '#cfe8c6'; ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw areas with enhanced visual style
    areas.forEach(a => {
      // Draw area background
      ctx.fillStyle = a.color;
      ctx.fillRect(a.x, a.y, a.w, a.h);

      // Draw border
      ctx.strokeStyle = a.borderColor || '#333';
      ctx.lineWidth = 4;
      ctx.strokeRect(a.x, a.y, a.w, a.h);

      // Draw icon if loaded
      if (a.icon && areaIcons[a.name] && a.iconLoaded !== false) {
        const iconSize = Math.min(96, Math.min(a.w, a.h) - 16);
        const ix = a.x + (a.w - iconSize) / 2;
        const iy = a.y + (a.h - iconSize) / 2;
        try {
          ctx.drawImage(areaIcons[a.name], ix, iy, iconSize, iconSize);
        } catch (e) {}
      }

      // Draw label
      ctx.font = 'bold 20px sans-serif';
      ctx.fillStyle = '#333';
      const textWidth = ctx.measureText(a.label).width;
      ctx.fillText(a.label, a.x + (a.w - textWidth) / 2, a.y + a.h - 10);
    });

    // draw players with enhanced visual style
    Object.values(players).forEach(p => {
      // Draw player circle
      ctx.fillStyle = (you && p.id === you.id) ? '#ff6b6b' : '#264653';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 20, 0, Math.PI*2);
      ctx.fill();
      
      // Add highlight effect
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw name with background for better visibility
      ctx.font = 'bold 16px sans-serif';
      const nameWidth = ctx.measureText(p.name).width;
      
      // Name background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(p.x - nameWidth/2 - 4, p.y - 40, nameWidth + 8, 22);
      
      // Name text
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.fillText(p.name, p.x, p.y - 24);
      ctx.textAlign = 'left';  // Reset alignment
    });

    requestAnimationFrame(render);
  }

  ws.addEventListener('open', () => {
    // Always prompt the user for their display name when they connect.
    // Prefill with stored name if available, otherwise suggest a random one.
    const stored = localStorage.getItem('name');
    const suggestion = stored || ('Player-' + Math.random().toString(36).slice(2,6));
    // show modal to confirm/change name on connect
    showNameModal(suggestion);
    needToJoin = true;
  });

  // helper to send join when user selects a name
  function sendJoinIfNeeded() {
    const name = localStorage.getItem('name');
    if (!hasJoined && name && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({type: 'join', name}));
      hasJoined = true;
      needToJoin = false;
    }
  }

  // support tapping the canvas to center player (mobile friendly)
  canvas.addEventListener('click', (e) => {
    if (!you) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    you.x = Math.max(10, Math.min(canvas.width - 10, x));
    you.y = Math.max(10, Math.min(canvas.height - 10, y));
    players[you.id] = you;
    ws.send(JSON.stringify({type: 'move', x: you.x, y: you.y}));
  });

  // Arcade menu handlers
  const arcadeMenu = document.getElementById('arcade-menu');
  const arcadePong = document.getElementById('arcade-pong');
  const arcadeBreakout = document.getElementById('arcade-breakout');
  const arcadeCancel = document.getElementById('arcade-cancel');

  function showArcadeMenu(){ arcadeMenu.classList.remove('hidden'); }
  function hideArcadeMenu(){ arcadeMenu.classList.add('hidden'); }

  arcadePong.addEventListener('click', () => {
    ws.send(JSON.stringify({type: 'start_game', game: 'pong', zone: 'arcade'}));
    hideArcadeMenu(); gamePrompt.classList.add('hidden');
  });
  arcadeBreakout.addEventListener('click', () => {
    ws.send(JSON.stringify({type: 'start_game', game: 'breakout', zone: 'arcade'}));
    hideArcadeMenu(); gamePrompt.classList.add('hidden');
  });
  arcadeCancel.addEventListener('click', () => { hideArcadeMenu(); });

  // also allow tapping the prompt to start the game
  gamePrompt.addEventListener('click', () => {
    if (gamePrompt.textContent.includes('Pong')) {
      ws.send(JSON.stringify({type: 'start_game', game: 'pong', zone: 'pong'}));
      gamePrompt.classList.add('hidden');
    } else if (gamePrompt.textContent.includes('Breakout')) {
      ws.send(JSON.stringify({type: 'start_game', game: 'breakout', zone: 'breakout'}));
      gamePrompt.classList.add('hidden');
    }
  });

  ws.addEventListener('message', (ev) => {
    const msg = JSON.parse(ev.data);
    console.log('[lobby] ws message', msg);
    if (msg.type === 'join_rejected') {
      console.log('[lobby] join rejected', msg);
      // show modal with suggestion
      showNameModal(msg.suggestion || '');
      addMessage('Name rejected by server: ' + (msg.reason || 'duplicate'));
      return;
    }
    if (msg.type === 'welcome') {
      you = msg.you;
      hasJoined = true;
      msg.players.forEach(p => players[p.id] = p);
      addMessage('Connected as ' + you.name);
    } else if (msg.type === 'player_joined') {
      players[msg.player.id] = msg.player;
      addMessage(msg.player.name + ' joined.');
    } else if (msg.type === 'player_left') {
      delete players[msg.id];
      addMessage('A player left.');
    } else if (msg.type === 'player_moved') {
      players[msg.player.id] = msg.player;
    } else if (msg.type === 'chat') {
      addMessage(msg.from + ': ' + msg.content);
    } else if (msg.type === 'game_invite') {
      // received an invitation to join a minigame
      // don't prompt the host
      console.log('[lobby] received game_invite', msg);
      if (!you || (msg.host && you.id === msg.host.id)) return;
      const accept = confirm(`${msg.host.name} invites you to play ${msg.game} in ${msg.zone}. Join?`);
      if (accept) {
        ws.send(JSON.stringify({type: 'join_game', host_id: msg.host.id}));
        console.log('[lobby] sent join_game', {host_id: msg.host.id});
      } else {
        // optionally send decline or just ignore
        addMessage(`You declined ${msg.host.name}'s invite.`);
      }

    } else if (msg.type === 'game_pending') {
      // host feedback that invite was sent
      addMessage(`Invite sent for ${msg.game} by ${msg.host.name}`);

    } else if (msg.type === 'game_started') {
      console.log('[lobby] received game_started', msg);
      addMessage(`${msg.host.name} started ${msg.game} in ${msg.zone}`);
      // open minigame only for participants; if participants include side assignments, pass them
      if (msg.zone === 'arcade' && msg.participants && you) {
        const me = msg.participants.find(p => p.id === you.id);
        if (me) {
          const side = (me.side || 'left');
          const ai = 'false';
          const hostId = (msg.host && msg.host.id) ? msg.host.id : '';
          let url = `/static/minigame.html?side=${encodeURIComponent(side)}&ai=${encodeURIComponent(ai)}&host=${encodeURIComponent(hostId)}`;
          // if breakout was chosen, open the breakout page instead
          if (msg.game === 'breakout') {
            url = `/static/breakout.html?host=${encodeURIComponent(hostId)}`;
          }
          // if we already opened a minigame window earlier, send it a message to switch to 2-player mode
          try {
            if (minigameWin && !minigameWin.closed) {
              console.log('[lobby] posting set_mode to existing minigameWin', {side, ai:false, host: hostId});
              // postMessage for pong; for breakout the page will ignore extra fields
              minigameWin.postMessage({type: 'set_mode', side, ai: false, host: hostId, game: msg.game}, window.location.origin);
              try { minigameWin.focus(); } catch(e){}
            } else {
              console.log('[lobby] opening minigame url', url);
              minigameWin = window.open(url, '_blank', 'width=900,height=640');
            }
          } catch (e) {
            console.error('[lobby] failed to message/open minigame window', e);
            // fallback: open a new window
            minigameWin = window.open(url, '_blank', 'width=900,height=640');
          }
        }
      }
    }
    // forward authoritative game_state messages to minigame window if present
    if (msg.type === 'game_state') {
      console.log('[lobby] game_state received', msg);
      try {
        if (minigameWin && !minigameWin.closed) {
          minigameWin.postMessage(msg, window.location.origin);
        }
      } catch (e) { console.error('[lobby] failed to post game_state', e); }
    }
    refreshPlayersList();
  });

  // Receive messages from minigame window and forward to server (proxy)
  window.addEventListener('message', (ev) => {
    // accept only same-origin
    if (ev.origin !== window.location.origin) return;
    const data = ev.data || {};
    if (data.type === 'paddle_move') {
      // forward to server with host reference
      const payload = {type: 'paddle_move', host_id: data.host, side: data.side, y: data.y};
      console.log('[lobby] forwarding paddle_move', payload);
      ws.send(JSON.stringify(payload));
    }
  });

  // Forward authoritative game_state from server to minigame window
  // server sends messages of type 'game_state' with host_id
  // We already log server messages; when a game_state arrives, postMessage to minigameWin
  const origOnMessage = ws.onmessage;

  // We don't need refreshPlayersList anymore since we're showing players directly on the canvas
  function refreshPlayersList() {}

  // Chat form handling
  if (chatForm) {
    chatForm.addEventListener('submit', (e) => {
      e.preventDefault();
      const text = chatInput.value.trim();
      if (!text) return;
      ws.send(JSON.stringify({type: 'chat', content: text}));
      chatInput.value = '';
      chatOverlay.classList.add('hidden');
    });
  }

  // Name modal UI
  const changeNameBtn = document.getElementById('change-name');
  // create modal elements
  const nameModal = document.createElement('div');
  nameModal.id = 'name-modal';
  nameModal.innerHTML = `
    <div class="modal-inner">
      <h3>Pick a display name</h3>
      <input id="name-input" placeholder="Your name" />
      <div class="modal-actions">
        <button id="name-save">Save</button>
      </div>
    </div>`;
  document.body.appendChild(nameModal);
  const nameInput = document.getElementById('name-input');
  const nameSave = document.getElementById('name-save');

  function showNameModal(prefill) {
    nameModal.style.display = 'flex';
    nameInput.value = prefill || '';
    nameInput.focus();
  }
  function hideNameModal(){ nameModal.style.display = 'none'; }

  changeNameBtn.addEventListener('click', () => { showNameModal(localStorage.getItem('name') || ''); });

  nameSave.addEventListener('click', () => {
    const v = nameInput.value.trim();
    if (!v) return;
    localStorage.setItem('name', v);
    hideNameModal();
    addMessage('Name set to ' + v);
    // if ws open but we haven't joined, send join now
    sendJoinIfNeeded();
  });

  // Always show name modal on start with a random name
  const randomName = 'Player-' + Math.random().toString(36).slice(2,6);
  showNameModal(localStorage.getItem('name') || randomName);

  // movement and interactions -- arrow keys / WASD
  const keys = {};
  window.addEventListener('keydown', e => { 
    keys[e.key] = true; 
    
    // Toggle chat with T key when near another player
    if (e.key === 't' && chatInput.dataset.nearPlayer) {
      e.preventDefault();
      chatOverlay.classList.toggle('hidden');
      if (!chatOverlay.classList.contains('hidden')) {
        chatInput.focus();
      }
    }
    
    // Start game with Space when in a building
    if (e.key === ' ' && !gamePrompt.classList.contains('hidden')) {
      e.preventDefault();
      if (gamePrompt.textContent.includes('Pong')) {
        ws.send(JSON.stringify({type: 'start_game', game: 'pong', zone: 'pong'}));
        gamePrompt.classList.add('hidden');
      } else if (gamePrompt.textContent.includes('Breakout')) {
        ws.send(JSON.stringify({type: 'start_game', game: 'breakout', zone: 'breakout'}));
        gamePrompt.classList.add('hidden');
      }
    }
  });
  window.addEventListener('keyup', e => { keys[e.key] = false; });

  function updatePosition() {
    if (!you) return;
    let dx = 0, dy = 0;
    if (keys['ArrowLeft'] || keys['a']) dx = -4;
    if (keys['ArrowRight'] || keys['d']) dx = 4;
    if (keys['ArrowUp'] || keys['w']) dy = -4;
    if (keys['ArrowDown'] || keys['s']) dy = 4;
    
    // Diagonal movement normalization
    if (dx && dy) {
      dx *= 0.707; // 1/√2
      dy *= 0.707;
    }
    
    if (dx || dy) {
      const newX = Math.max(20, Math.min(GAME_WIDTH - 20, you.x + dx));
      const newY = Math.max(20, Math.min(GAME_HEIGHT - 20, you.y + dy));
      
      // Only send update if position actually changed
      if (newX !== you.x || newY !== you.y) {
        you.x = newX;
        you.y = newY;
        players[you.id] = you;
        ws.send(JSON.stringify({type: 'move', x: you.x, y: you.y}));
      }
    }
  }

  function checkCollisions() {
    if (!you) return;
    
    // Check for player collisions (within 30 pixels)
    let nearPlayer = false;
    Object.values(players).forEach(other => {
      if (other.id === you.id) return; // Skip self
      const dx = other.x - you.x;
      const dy = other.y - you.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < 30) {
        // Players are close enough to chat
        chatOverlay.classList.remove('hidden');
        chatInput.placeholder = `Chat with ${other.name}...`;
        chatInput.dataset.nearPlayer = other.id;
        nearPlayer = true;
      }
    });
    
    if (!nearPlayer) {
      chatOverlay.classList.add('hidden');
    }
    
    // Check for each building
    let inPong = false, inBreakout = false;
    areas.forEach(a => {
      if (you.x > a.x && you.x < a.x + a.w && you.y > a.y && you.y < a.y + a.h) {
        if (a.name === 'pong') inPong = true;
        if (a.name === 'breakout') inBreakout = true;
      }
    });
    if (inPong) {
      gamePrompt.textContent = 'Press SPACE to play Pong';
      gamePrompt.classList.remove('hidden');
    } else if (inBreakout) {
      gamePrompt.textContent = 'Press SPACE to play Breakout';
      gamePrompt.classList.remove('hidden');
    } else {
      gamePrompt.classList.add('hidden');
      try { if (arcadeMenu) arcadeMenu.classList.add('hidden'); } catch(e){}
    }
  }

  // Clear chat target when moving away
  function clearChatTarget() {
    chatInput.placeholder = "Say something...";
    delete chatInput.dataset.nearPlayer;
  }

  // Game loop
  setInterval(updatePosition, 50);
  setInterval(checkCollisions, 200);
  requestAnimationFrame(render);


})();
</script>
</body>
</html>
